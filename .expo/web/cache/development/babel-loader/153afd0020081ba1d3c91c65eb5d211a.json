{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nvar _jsxFileName = \"/Users/aleksimpson/Desktop/Cogniprint/RenderButtons.js\";\nimport Amplify, { Storage } from 'aws-amplify';\nimport config from \"./aws-exports\";\nAmplify.configure(config);\nimport 'react-native-gesture-handler';\nimport * as React from 'react';\nimport { useEffect } from 'react';\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport Dimensions from \"react-native-web/dist/exports/Dimensions\";\nimport { TouchableOpacity } from 'react-native-gesture-handler';\nimport { CardView } from \"./CardView.js\";\nimport * as Permissions from 'expo-permissions';\nimport * as Notifications from 'expo-notifications';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { updatePrinter } from \"./updatePrinters.js\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport { RenderButtonStyles as styles } from \"./Styles.js\";\n\nfunction RenderButtons(_ref) {\n  var _this = this;\n\n  var navigation = _ref.navigation;\n  var listPrinters = useSelector(function (state) {\n    return state.listP;\n  });\n  var dispatch = useDispatch();\n  var isWeb = Platform.OS == 'web' ? true : false;\n\n  function calculateTimeExpired(printer) {\n    var currentTime = new Date();\n    var printerUpdated = new Date(printer.updatedAt);\n    var diff = Math.abs(currentTime - printerUpdated) / 1000;\n    var expiredTime = diff > 5 * 60;\n    return expiredTime;\n  }\n\n  function offlineDetection() {\n    var i = 0;\n    listPrinters.forEach(function (printer) {\n      if (printer.printerState != null && printer.status != 0) {\n        var timeExpired = calculateTimeExpired(printer);\n\n        if (timeExpired) {\n          var newListPrinters = _toConsumableArray(listPrinters);\n\n          newListPrinters[i].status = 0;\n          dispatch(updatePrinter(newListPrinters));\n        }\n      }\n\n      i++;\n    });\n  }\n\n  if (!isWeb) {\n    registerForPushNotificationsAsync = function registerForPushNotificationsAsync() {\n      var _await$Permissions$ge, existingStatus, finalStatus, _await$Permissions$as, status, token;\n\n      return _regeneratorRuntime.async(function registerForPushNotificationsAsync$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!Constants.isDevice) {\n                _context.next = 22;\n                break;\n              }\n\n              _context.next = 3;\n              return _regeneratorRuntime.awrap(Permissions.getAsync(Permissions.NOTIFICATIONS));\n\n            case 3:\n              _await$Permissions$ge = _context.sent;\n              existingStatus = _await$Permissions$ge.status;\n              finalStatus = existingStatus;\n\n              if (!(existingStatus !== 'granted')) {\n                _context.next = 12;\n                break;\n              }\n\n              _context.next = 9;\n              return _regeneratorRuntime.awrap(Permissions.askAsync(Permissions.NOTIFICATIONS));\n\n            case 9:\n              _await$Permissions$as = _context.sent;\n              status = _await$Permissions$as.status;\n              finalStatus = status;\n\n            case 12:\n              if (!(finalStatus !== 'granted')) {\n                _context.next = 15;\n                break;\n              }\n\n              alert('Failed to get push token for push notification!');\n              return _context.abrupt(\"return\");\n\n            case 15:\n              _context.next = 17;\n              return _regeneratorRuntime.awrap(Notifications.getExpoPushTokenAsync());\n\n            case 17:\n              token = _context.sent;\n              console.log(token);\n\n              _this.setState({\n                expoPushToken: token\n              });\n\n              _context.next = 23;\n              break;\n\n            case 22:\n              alert('Must use physical device for Push Notifications');\n\n            case 23:\n              if (Platform.OS === 'android') {\n                Notifications.createChannelAndroidAsync('default', {\n                  name: 'default',\n                  sound: true,\n                  priority: 'max',\n                  vibrate: [0, 250, 250, 250]\n                });\n              }\n\n            case 24:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    };\n  }\n\n  useEffect(function () {\n    setInterval(offlineDetection, 1000);\n  }, []);\n\n  var handlePress = function handlePress(printer) {\n    requestAnimationFrame(function () {\n      navigation.navigate('Detail Screen', {\n        printer: printer\n      });\n    });\n  };\n\n  return listPrinters.map(function (printer) {\n    return React.createElement(TouchableOpacity, {\n      key: printer.id,\n      style: styles.touchable,\n      onPress: function onPress() {\n        return handlePress(printer);\n      },\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 115,\n        columnNumber: 7\n      }\n    }, React.createElement(CardView, {\n      printer: printer,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 116,\n        columnNumber: 9\n      }\n    }));\n  });\n}\n\nexport { RenderButtons };","map":{"version":3,"sources":["/Users/aleksimpson/Desktop/Cogniprint/RenderButtons.js"],"names":["Amplify","Storage","config","configure","React","useEffect","TouchableOpacity","CardView","Permissions","Notifications","useSelector","useDispatch","updatePrinter","RenderButtonStyles","styles","RenderButtons","navigation","listPrinters","state","listP","dispatch","isWeb","Platform","OS","calculateTimeExpired","printer","currentTime","Date","printerUpdated","updatedAt","diff","Math","abs","expiredTime","offlineDetection","i","forEach","printerState","status","timeExpired","newListPrinters","registerForPushNotificationsAsync","Constants","isDevice","getAsync","NOTIFICATIONS","existingStatus","finalStatus","askAsync","alert","getExpoPushTokenAsync","token","console","log","setState","expoPushToken","createChannelAndroidAsync","name","sound","priority","vibrate","setInterval","handlePress","requestAnimationFrame","navigate","map","id","touchable"],"mappings":"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","sourcesContent":["import Amplify, { Storage } from 'aws-amplify'\nimport config from './aws-exports'\nAmplify.configure(config)\nimport 'react-native-gesture-handler';\nimport * as React from 'react';\nimport { useEffect } from 'react'\nimport { StyleSheet, Dimensions } from 'react-native';\nimport { TouchableOpacity } from 'react-native-gesture-handler';\nimport { CardView } from './CardView.js';\nimport * as Permissions from 'expo-permissions';\nimport * as Notifications from 'expo-notifications';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { updatePrinter } from './updatePrinters.js';\nimport { Platform } from 'react-native'\nimport { RenderButtonStyles as styles } from './Styles.js'\n\nfunction RenderButtons({ navigation })\n{\n  const listPrinters = useSelector(state => { return state.listP })\n  \n  const dispatch = useDispatch()\n\n  var isWeb = (Platform.OS == 'web' ? true : false)\n\n  //Calculates if the printer has expired\n  function calculateTimeExpired(printer)\n  {\n    let currentTime = new Date()\n    let printerUpdated = new Date(printer.updatedAt)\n    let diff = Math.abs(currentTime - printerUpdated) / 1000;\n    let expiredTime = diff > (5 * 60)\n    return expiredTime\n  }\n\n  //Detects if the printer has been disconnected\n  function offlineDetection()\n  {\n    let i = 0\n    listPrinters.forEach(function (printer) \n    {\n      if (printer.printerState != null && printer.status != 0)\n      {\n        let timeExpired = calculateTimeExpired(printer)\n        if (timeExpired)\n        {\n          var newListPrinters = [...listPrinters]\n          \n          newListPrinters[i].status = 0\n          dispatch(updatePrinter(newListPrinters)) /* SHOULD PROBABLY RUN A MUTATION TO FIX THIS ON THE API AS WELL */\n        }\n      }\n      i++\n    })\n  }\n  \n  //Stuff for push notifications\n  \n  if (!isWeb)\n  {\n    registerForPushNotificationsAsync = async () => \n    {\n      if (Constants.isDevice) \n      {\n        const { status: existingStatus } = await Permissions.getAsync(Permissions.NOTIFICATIONS);\n        let finalStatus = existingStatus;\n        if (existingStatus !== 'granted') \n        {\n          const { status } = await Permissions.askAsync(Permissions.NOTIFICATIONS);\n          finalStatus = status;\n        }\n        if (finalStatus !== 'granted') \n        {\n          alert('Failed to get push token for push notification!');\n          return;\n        }\n        const token = await Notifications.getExpoPushTokenAsync();\n        console.log(token);\n        this.setState({ expoPushToken: token });\n      } else \n      {\n        alert('Must use physical device for Push Notifications');\n      }\n  \n      if (Platform.OS === 'android') \n      {\n        Notifications.createChannelAndroidAsync('default', \n        {\n          name: 'default',\n          sound: true,\n          priority: 'max',\n          vibrate: [0, 250, 250, 250],\n        });\n      }\n    };\n  }\n\n  useEffect(() => \n  {\n    setInterval(offlineDetection, 1000)\n  }, [])\n  \n  //handles touchable opacity press\n  const handlePress = (printer) => \n  {\n    //here to optimize for performance\n    requestAnimationFrame(() => \n    { \n      navigation.navigate('Detail Screen', { printer: printer }) \n    });\n  }\n\n  return listPrinters.map((printer) => \n  {\n    return (\n      <TouchableOpacity key={printer.id} style={styles.touchable} onPress={ () => handlePress(printer) } > \n        <CardView printer={printer}/>\n      </TouchableOpacity>\n    );\n  });\n}\n\nexport { RenderButtons }"]},"metadata":{},"sourceType":"module"}