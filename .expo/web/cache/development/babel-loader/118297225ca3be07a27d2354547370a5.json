{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nvar _jsxFileName = \"/Users/aleksimpson/Desktop/Cogniprint/RenderButtons.js\";\nimport Amplify, { Storage } from 'aws-amplify';\nimport config from \"./aws-exports\";\nAmplify.configure(config);\nimport 'react-native-gesture-handler';\nimport * as React from 'react';\nimport { useEffect } from 'react';\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport Dimensions from \"react-native-web/dist/exports/Dimensions\";\nimport { TouchableOpacity } from 'react-native-gesture-handler';\nimport { CardView } from \"./CardView.js\";\nimport * as Permissions from 'expo-permissions';\nimport * as Notifications from 'expo-notifications';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { updatePrinter } from \"./updatePrinters.js\";\nvar styles = StyleSheet.create({\n  touchable: {\n    alignItems: 'center',\n    justifyContent: 'center',\n    backgroundColor: 'rgb(21, 34, 56)'\n  }\n});\n\nfunction RenderButtons(_ref) {\n  var _this = this;\n\n  var navigation = _ref.navigation;\n  var listPrinters = useSelector(function (state) {\n    return state.listP;\n  });\n  var dispatch = useDispatch();\n\n  function calculateTimeExpired(printer) {\n    var currentTime = new Date();\n    var printerUpdated = new Date(printer.updatedAt);\n    var diff = Math.abs(currentTime - printerUpdated) / 1000;\n    var expiredTime = diff > 5 * 60;\n    return expiredTime;\n  }\n\n  function offlineDetection() {\n    var i = 0;\n    listPrinters.forEach(function (printer) {\n      if (printer.printerState != null) {\n        if (printer.status != 0) {\n          var timeExpired = calculateTimeExpired(printer);\n\n          if (timeExpired) {\n            var newListPrinters = _toConsumableArray(listPrinters);\n\n            newListPrinters[i].status = 0;\n            dispatch(updatePrinter(newListPrinters));\n          }\n        }\n      }\n\n      i++;\n    });\n  }\n\n  registerForPushNotificationsAsync = function registerForPushNotificationsAsync() {\n    var _await$Permissions$ge, existingStatus, finalStatus, _await$Permissions$as, status, token;\n\n    return _regeneratorRuntime.async(function registerForPushNotificationsAsync$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (!Constants.isDevice) {\n              _context.next = 22;\n              break;\n            }\n\n            _context.next = 3;\n            return _regeneratorRuntime.awrap(Permissions.getAsync(Permissions.NOTIFICATIONS));\n\n          case 3:\n            _await$Permissions$ge = _context.sent;\n            existingStatus = _await$Permissions$ge.status;\n            finalStatus = existingStatus;\n\n            if (!(existingStatus !== 'granted')) {\n              _context.next = 12;\n              break;\n            }\n\n            _context.next = 9;\n            return _regeneratorRuntime.awrap(Permissions.askAsync(Permissions.NOTIFICATIONS));\n\n          case 9:\n            _await$Permissions$as = _context.sent;\n            status = _await$Permissions$as.status;\n            finalStatus = status;\n\n          case 12:\n            if (!(finalStatus !== 'granted')) {\n              _context.next = 15;\n              break;\n            }\n\n            alert('Failed to get push token for push notification!');\n            return _context.abrupt(\"return\");\n\n          case 15:\n            _context.next = 17;\n            return _regeneratorRuntime.awrap(Notifications.getExpoPushTokenAsync());\n\n          case 17:\n            token = _context.sent;\n            console.log(token);\n\n            _this.setState({\n              expoPushToken: token\n            });\n\n            _context.next = 23;\n            break;\n\n          case 22:\n            alert('Must use physical device for Push Notifications');\n\n          case 23:\n            if (Platform.OS === 'android') {\n              Notifications.createChannelAndroidAsync('default', {\n                name: 'default',\n                sound: true,\n                priority: 'max',\n                vibrate: [0, 250, 250, 250]\n              });\n            }\n\n          case 24:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  };\n\n  useEffect(function () {\n    setInterval(offlineDetection, 1000);\n  }, []);\n\n  var handlePress = function handlePress(printer) {\n    requestAnimationFrame(function () {\n      navigation.navigate('Detail Screen', {\n        printer: printer\n      });\n    });\n  };\n\n  return listPrinters.map(function (printer) {\n    return React.createElement(TouchableOpacity, {\n      key: printer.id,\n      style: styles.touchable,\n      onPress: function onPress() {\n        return handlePress(printer);\n      },\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 119,\n        columnNumber: 7\n      }\n    }, React.createElement(CardView, {\n      printer: printer,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 120,\n        columnNumber: 9\n      }\n    }));\n  });\n}\n\nexport { RenderButtons };","map":{"version":3,"sources":["/Users/aleksimpson/Desktop/Cogniprint/RenderButtons.js"],"names":["Amplify","Storage","config","configure","React","useEffect","TouchableOpacity","CardView","Permissions","Notifications","useSelector","useDispatch","updatePrinter","styles","StyleSheet","create","touchable","alignItems","justifyContent","backgroundColor","RenderButtons","navigation","listPrinters","state","listP","dispatch","calculateTimeExpired","printer","currentTime","Date","printerUpdated","updatedAt","diff","Math","abs","expiredTime","offlineDetection","i","forEach","printerState","status","timeExpired","newListPrinters","registerForPushNotificationsAsync","Constants","isDevice","getAsync","NOTIFICATIONS","existingStatus","finalStatus","askAsync","alert","getExpoPushTokenAsync","token","console","log","setState","expoPushToken","Platform","OS","createChannelAndroidAsync","name","sound","priority","vibrate","setInterval","handlePress","requestAnimationFrame","navigate","map","id"],"mappings":"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","sourcesContent":["import Amplify, { Storage } from 'aws-amplify'\nimport config from './aws-exports'\nAmplify.configure(config)\nimport 'react-native-gesture-handler';\nimport * as React from 'react';\nimport { useEffect } from 'react'\nimport { StyleSheet, Dimensions } from 'react-native';\nimport { TouchableOpacity } from 'react-native-gesture-handler';\nimport { CardView } from './CardView.js';\nimport * as Permissions from 'expo-permissions';\nimport * as Notifications from 'expo-notifications';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { updatePrinter } from './updatePrinters.js';\n\nconst styles = StyleSheet.create({\n  touchable:\n  {\n    alignItems: 'center',\n    justifyContent: 'center',\n    backgroundColor:'rgb(21, 34, 56)'\n  },\n})\n\nfunction RenderButtons({ navigation })\n{\n  const listPrinters = useSelector(state => { return state.listP })\n  \n  const dispatch = useDispatch()\n\n  //Calculates if the printer has expired\n  function calculateTimeExpired(printer)\n  {\n    let currentTime = new Date()\n    let printerUpdated = new Date(printer.updatedAt)\n    let diff = Math.abs(currentTime - printerUpdated) / 1000;\n    let expiredTime = diff > (5 * 60)\n    return expiredTime\n  }\n\n  //Detects if the printer has been disconnected\n  function offlineDetection()\n  {\n    let i = 0\n    listPrinters.forEach(function (printer) \n    {\n      if (printer.printerState != null)\n      {\n        if (printer.status != 0)\n        {\n          let timeExpired = calculateTimeExpired(printer)\n          if (timeExpired)\n          {\n            var newListPrinters = [...listPrinters]\n            \n            newListPrinters[i].status = 0\n            dispatch(updatePrinter(newListPrinters)) /* SHOULD PROBABLY RUN A MUTATION TO FIX THIS ON THE API AS WELL */\n          }\n        }\n      }\n      i++\n    })\n  }\n  \n  //Stuff for push notifications\n  registerForPushNotificationsAsync = async () => \n  {\n    if (Constants.isDevice) \n    {\n      const { status: existingStatus } = await Permissions.getAsync(Permissions.NOTIFICATIONS);\n      let finalStatus = existingStatus;\n      if (existingStatus !== 'granted') \n      {\n        const { status } = await Permissions.askAsync(Permissions.NOTIFICATIONS);\n        finalStatus = status;\n      }\n      if (finalStatus !== 'granted') \n      {\n        alert('Failed to get push token for push notification!');\n        return;\n      }\n      const token = await Notifications.getExpoPushTokenAsync();\n      console.log(token);\n      this.setState({ expoPushToken: token });\n    } else \n    {\n      alert('Must use physical device for Push Notifications');\n    }\n  \n    if (Platform.OS === 'android') \n    {\n      Notifications.createChannelAndroidAsync('default', \n      {\n        name: 'default',\n        sound: true,\n        priority: 'max',\n        vibrate: [0, 250, 250, 250],\n      });\n    }\n  };\n\n  useEffect(() => \n  {\n    setInterval(offlineDetection, 1000)\n  }, [])\n  \n  //handles touchable opacity press\n  const handlePress = (printer) => \n  {\n    //here to optimize for performance\n    requestAnimationFrame(() => \n    { \n      navigation.navigate('Detail Screen', { printer: printer }) \n    });\n  }\n\n  return listPrinters.map((printer) => \n  {\n    return (\n      <TouchableOpacity key={printer.id} style={styles.touchable} onPress={ () => handlePress(printer) } > \n        <CardView printer={printer}/>\n      </TouchableOpacity>\n    );\n  });\n}\n\nexport { RenderButtons }"]},"metadata":{},"sourceType":"module"}