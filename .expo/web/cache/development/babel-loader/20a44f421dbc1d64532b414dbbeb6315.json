{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport * as React from 'react';\nimport { useReducer } from 'react';\nimport { updatePrinter } from \"./updatePrinters.js\";\nimport { updatePrinterDict } from \"./updatePrinterDict.js\";\nimport store from \"./store.js\";\nimport { Auth } from 'aws-amplify';\nimport Amplify, { API, graphqlOperation, Storage } from 'aws-amplify';\nimport { printersByOwner, listPrints } from \"./graphql/queries\";\nimport * as subscriptions from \"./graphql/subscriptions\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nvar printerImageDict = {};\nvar tempListPrinters = [];\n\nfunction fetchPrinters() {\n  var nextToken,\n      refresh,\n      sortMethod,\n      isResort,\n      sortPrintersBy,\n      user,\n      printerData,\n      printers,\n      newNextToken,\n      data,\n      subscription,\n      addToDict,\n      downloadImage,\n      downloadAllImages,\n      _args = arguments;\n  return _regeneratorRuntime.async(function fetchPrinters$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          downloadAllImages = function _downloadAllImages() {\n            for (i = 0; i < tempListPrinters.length; i++) {\n              downloadImage(tempListPrinters[i]);\n            }\n          };\n\n          downloadImage = function _downloadImage(printer) {\n            Storage.get(printer.picture.key, {\n              level: 'public',\n              customPrefix: {\n                public: ''\n              }\n            }).then(function (result) {\n              return addToDict(printer.id, result, true);\n            }).catch(function (err) {\n              return console.log(err);\n            });\n          };\n\n          addToDict = function _addToDict(key, value, save) {\n            printerImageDict[key] = value;\n\n            if (save) {\n              saveImage(key + '.jpg', value);\n            }\n\n            if (Object.keys(printerImageDict).length == tempListPrinters.length) {\n              store.dispatch(updatePrinterDict(printerImageDict));\n              printerImageDict = {};\n              tempListPrinters = [];\n            }\n          };\n\n          sortPrintersBy = function _sortPrintersBy(method) {\n            function sortByFailureRisk() {\n              tempListPrinters.sort(function (a, b) {\n                return b.status - a.status;\n              });\n              tempListPrinters.sort(function (a, b) {\n                var aPred = a.printerState != null && a.printerState.failure != null && a.printerState.failure.currentPred != null ? a.printerState.failure.currentPred : 0.0;\n                var bPred = b.printerState != null && b.printerState.failure != null && b.printerState.failure.currentPred != null ? b.printerState.failure.currentPred : 0.0;\n                return bPred - aPred;\n              });\n            }\n\n            switch (method) {\n              case 'Failure Risk':\n                sortByFailureRisk();\n                break;\n\n              case 'Alphabetical Order':\n                tempListPrinters.sort(function (a, b) {\n                  var fa = a.name.toLowerCase(),\n                      fb = b.name.toLowerCase();\n\n                  if (fa < fb) {\n                    return -1;\n                  }\n\n                  if (fa > fb) {\n                    return 1;\n                  }\n\n                  return 0;\n                });\n                break;\n\n              default:\n                sortByFailureRisk();\n            }\n          };\n\n          nextToken = _args.length > 0 && _args[0] !== undefined ? _args[0] : null;\n          refresh = _args.length > 1 && _args[1] !== undefined ? _args[1] : false;\n          sortMethod = _args.length > 2 && _args[2] !== undefined ? _args[2] : 'Failure Risk';\n          isResort = _args.length > 3 && _args[3] !== undefined ? _args[3] : false;\n\n          if (refresh && nextToken == null) {\n            clearStorage();\n          }\n\n          _context.prev = 9;\n          _context.next = 12;\n          return _regeneratorRuntime.awrap(Auth.currentUserInfo());\n\n        case 12:\n          user = _context.sent;\n          _context.next = 15;\n          return _regeneratorRuntime.awrap(API.graphql(graphqlOperation(printersByOwner, {\n            owner: user.username,\n            nextToken: nextToken\n          })));\n\n        case 15:\n          printerData = _context.sent;\n          printers = printerData.data.printersByOwner.items;\n          newNextToken = printerData.data.printersByOwner.nextToken;\n          tempListPrinters = tempListPrinters.concat(printers);\n\n          if (!(newNextToken != null)) {\n            _context.next = 23;\n            break;\n          }\n\n          fetchPrinters(newNextToken, refresh, sortMethod);\n          _context.next = 31;\n          break;\n\n        case 23:\n          sortPrintersBy(sortMethod);\n          store.dispatch(updatePrinter(tempListPrinters));\n\n          if (isResort) {\n            _context.next = 31;\n            break;\n          }\n\n          _context.next = 28;\n          return _regeneratorRuntime.awrap(checkForSavedData());\n\n        case 28:\n          data = _context.sent;\n\n          if (data.length !== 0 && !refresh && Platform.OS !== \"web\") {\n            retrieveFromStorage();\n          } else {\n            downloadAllImages();\n          }\n\n          if (!refresh) {\n            subscription = API.graphql(graphqlOperation(subscriptions.onCreateTodo)).subscribe({\n              next: function next(todoData) {\n                return console.log(todoData);\n              }\n            });\n          }\n\n        case 31:\n          _context.next = 36;\n          break;\n\n        case 33:\n          _context.prev = 33;\n          _context.t0 = _context[\"catch\"](9);\n          console.log(_context.t0);\n\n        case 36:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, [[9, 33]], Promise);\n}\n\nexport { fetchPrinters };","map":{"version":3,"sources":["/Users/aleksimpson/Desktop/Cogniprint/FetchPrinters.js"],"names":["React","useReducer","updatePrinter","updatePrinterDict","store","Auth","Amplify","API","graphqlOperation","Storage","printersByOwner","listPrints","subscriptions","printerImageDict","tempListPrinters","fetchPrinters","sortPrintersBy","addToDict","downloadImage","downloadAllImages","i","length","printer","get","picture","key","level","customPrefix","public","then","result","id","catch","err","console","log","value","save","saveImage","Object","keys","dispatch","method","sortByFailureRisk","sort","a","b","status","aPred","printerState","failure","currentPred","bPred","fa","name","toLowerCase","fb","nextToken","refresh","sortMethod","isResort","clearStorage","currentUserInfo","user","graphql","owner","username","printerData","printers","data","items","newNextToken","concat","checkForSavedData","Platform","OS","retrieveFromStorage","subscription","onCreateTodo","subscribe","next","todoData"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { useReducer } from 'react'\n// import * as FileSystem from 'expo-file-system';\nimport { updatePrinter } from './updatePrinters.js';\nimport { updatePrinterDict } from './updatePrinterDict.js';\nimport store from './store.js';\nimport { Auth } from 'aws-amplify';\nimport Amplify, { API, graphqlOperation, Storage } from 'aws-amplify';\nimport { printersByOwner, listPrints } from './graphql/queries'\nimport * as subscriptions from './graphql/subscriptions';\nimport { Platform } from 'react-native'\n\nvar printerImageDict = {};\n\nvar tempListPrinters = []\n\n//Fetches the printer data from the API\nasync function fetchPrinters(nextToken = null, refresh = false, sortMethod = 'Failure Risk', isResort = false)\n{\n    if ((refresh) && (nextToken == null))\n    {\n        clearStorage()\n    }\n    //Sorts the fetched printers\n    function sortPrintersBy(method)\n    {\n        function sortByFailureRisk()\n        {\n            tempListPrinters.sort((a, b) => {\n                return b.status - a.status;\n            })\n            tempListPrinters.sort((a, b) => {\n                let aPred = ((a.printerState != null && a.printerState.failure != null && a.printerState.failure.currentPred != null) ? a.printerState.failure.currentPred : 0.0)\n                let bPred = ((b.printerState != null && b.printerState.failure != null && b.printerState.failure.currentPred != null) ? b.printerState.failure.currentPred : 0.0)\n                return bPred - aPred\n            })\n        }\n        switch (method)\n        {\n            case 'Failure Risk':\n                sortByFailureRisk()\n                break \n            case 'Alphabetical Order':\n                tempListPrinters.sort((a, b) => {\n                    let fa = a.name.toLowerCase(),\n                        fb = b.name.toLowerCase()\n                    \n                    if (fa < fb)\n                    {\n                        return -1\n                    }\n                    if (fa > fb)\n                    {\n                        return 1\n                    }\n\n                    return 0\n                })\n                break\n            default: \n                //sort by failure risk by default\n                sortByFailureRisk()\n        }\n    }\n\n    try\n    {\n        const user = await Auth.currentUserInfo();\n        const printerData = await API.graphql(graphqlOperation(printersByOwner, {owner: user.username, nextToken: nextToken}))\n        const printers = printerData.data.printersByOwner.items\n        \n        let newNextToken = printerData.data.printersByOwner.nextToken\n        \n        tempListPrinters = tempListPrinters.concat(printers)\n\n        if (newNextToken != null)\n        {\n            fetchPrinters(newNextToken, refresh, sortMethod)\n        }else \n        {\n            sortPrintersBy(sortMethod)\n\n            store.dispatch(updatePrinter(tempListPrinters))\n            \n            if (!isResort)\n            {\n                let data = await checkForSavedData()\n                if (data.length !== 0 && (!refresh)  && Platform.OS !== \"web\")\n                {\n                    retrieveFromStorage()\n                }else \n                {\n                    downloadAllImages()\n                }\n                if (!refresh)\n                {\n                    //Subscribe to creation of Todo\n                    const subscription = API.graphql(\n                        graphqlOperation(subscriptions.onCreateTodo)\n                    ).subscribe({\n                        next: (todoData) => console.log(todoData)\n                    });\n                }\n            }\n        }\n    } catch (err) { console.log(err) }\n\n    //Adds the printer to the image dictionary\n    function addToDict(key, value, save)\n    {\n        printerImageDict[key] = value\n        if (save)\n        {\n            saveImage(key + '.jpg', value)\n        }\n        if (Object.keys(printerImageDict).length == tempListPrinters.length)\n        {\n            store.dispatch(updatePrinterDict(printerImageDict))\n            printerImageDict = {}\n            tempListPrinters = []\n        }\n    }\n\n    //Gets the s3Image url\n    function downloadImage(printer)\n    {\n        Storage.get(printer.picture.key, { level: 'public', customPrefix: { public: ''} })\n            .then(result => addToDict(printer.id, result, true))\n            .catch(err => console.log(err));\n    }\n\n    //Downloads all images\n    function downloadAllImages()\n    {\n        for (i = 0; i < tempListPrinters.length; i++)\n        {\n            downloadImage(tempListPrinters[i])\n        }\n    }\n\n    //saves new data (url = value, fileName = key)\n    // function saveImage(key, value)\n    // {\n    //     FileSystem.downloadAsync(value, FileSystem.documentDirectory + key)\n    //         .then(({ uri }) => \n    //         {\n    //             //console.log('Finished downloading to ', uri);\n    //         })\n    //         .catch(error => \n    //         {\n    //             console.error(error);\n    //         });\n    // }\n\n    // //checks if data has already been saved\n    // async function checkForSavedData()\n    // {\n    //     var returnValue = []\n    //     for (var i = 0; i < tempListPrinters.length; i++)\n    //     {\n    //         let path = FileSystem.documentDirectory + tempListPrinters[i].id + '.jpg'\n    //         let data = await FileSystem.getInfoAsync(path)\n    //         if (data.exists)\n    //         {\n    //             returnValue = returnValue.concat(path)\n    //         }\n    //     }\n    //     return returnValue\n    // }\n\n    // //retrieves all saved\n    // function retrieveFromStorage()\n    // {\n    //     for (i = 0; i < tempListPrinters.length; i++)\n    //     {\n    //         let path = FileSystem.documentDirectory + tempListPrinters[i].id + '.jpg'\n\n    //         addToDict(tempListPrinters[i].id, path, false)\n    //     }\n    // }\n\n    // //Clears out all persistent data being stored for new data\n    // async function clearStorage()\n    // {\n    //     //Refactor this with the clear function in SaveDataManager.js\n    //     let persistentCleared = await checkForSavedData()\n    //     if (persistentCleared.length !== 0)\n    //     {\n    //         for (i=0; i<Object.keys(images).length; i++)\n    //         {\n    //             FileSystem.deleteAsync(images[Object.keys(images)[i]])\n    //         }\n    //     }\n    // }\n}\n\nexport { fetchPrinters };"]},"metadata":{},"sourceType":"module"}